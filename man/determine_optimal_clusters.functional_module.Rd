% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/11_1_determine_optimal_clutsers.R
\name{determine_optimal_clusters.functional_module}
\alias{determine_optimal_clusters.functional_module}
\title{Determine Optimal Clustering for Functional Modules}
\usage{
\method{determine_optimal_clusters}{functional_module}(
  object,
  cutoff_range = c(0.2, 0.9),
  cutoff_increment = 0.05,
  methods = c("h_ward.D", "binary_cut", "louvain"),
  ...
)
}
\arguments{
\item{object}{An \strong{S4} \emph{functional_module} object (typically the output of
\code{mapa::get_functional_modules()}).}

\item{cutoff_range}{Numeric vector of length 2 giving the lower and upper
bounds (inclusive) of the similarity threshold to test.
Must be in \verb{[0, 1]}; default is \code{c(0.2, 0.9)}.}

\item{cutoff_increment}{Numeric step size used to generate the sequence of
cutoffs inside \code{cutoff_range}. Default is \code{0.05}.}

\item{methods}{Character vector of clustering approaches to evaluate.
The following values are recognised (any mix allowed):
\itemize{
\item \strong{Hierarchical} ‒ supply \code{"h_<agglom.method>"}, where
\verb{<agglom.method>} is one of
\code{"ward.D"}, \code{"ward.D2"}, \code{"single"}, \code{"complete"}, \code{"average"},
\code{"mcquitty"}, \code{"median"}, \code{"centroid"}.
\item \code{"binary_cut"}
\item Graph-based: \code{"louvain"}, \code{"walktrap"}, \code{"infomap"},
\code{"edge_betweenness"}, \code{"fast_greedy"}, \code{"label_prop"},
\code{"leading_eigen"}, \code{"optimal"}
}
Default: \code{c("h_ward.D", "binary_cut", "louvain")}.}

\item{...}{Reserved for future extensions; currently ignored.}
}
\value{
A \strong{list} with three elements:
\itemize{
\item \strong{\code{cluster_result}} – a \code{data.frame} summarising every
method/cut-off combination with its modularity and silhouette scores;
\item \strong{\code{evaluation_plot}} – a \code{ggplot2} object visualising the score landscape;
\item \strong{\code{best_combination}} – the row of \code{cluster_result} corresponding to the
globally optimal settings.
}
}
\description{
Identify the best clustering configuration for a \strong{\code{functional_module}} object.
The function builds a Jaccard similarity matrix for all pathways and evaluates
multiple clustering algorithms across a range of similarity cutoffs, selecting
the combination that maximizes a composite of modularity and silhouette scores.
}
\examples{
\dontrun{
# Assume `enrichment_obj` is a processed functional_module object
# Explore graph-based algorithms over a narrower similarity range
res <- determine_optimal_clusters(
  enrichment_obj,
  cutoff_range = c(0.1, 0.7),
  methods = c("louvain", "walktrap", "fast_greedy", "optimal")
)

# Retrieve the winning settings
res$best_combination
}

}
